<resources>
    <string name="app_name">Data Structure</string>
    <string-array name="code_operation">
        <item>show code on clicked button</item>
        <item>do operation on clicked button</item>
    </string-array>
    <string name="data_edit_text">enter data</string>
    <string name="index_edit_text">enter index</string>
    <string-array name="insertion_choice_array">
        <item>insert at first</item>
        <item>insert at last</item>
        <item>insert at specific index</item>
        <item>insert in sorted array</item>
    </string-array>
    <string-array name="insertion_choice_list">
        <item>insert at first</item>
        <item>insert at last</item>
        <item>insert at specific index</item>
        <item>insert in sorted list</item>
    </string-array>

    <string-array name="deletion_choice">
        <item>delete specific item</item>
        <item>delete first</item>
        <item>delete last</item>
        <item>delete from specific index</item>

    </string-array>
    <string-array name="search_choice">
        <item>linear search</item>
        <item>binary search</item>
    </string-array>
    <string-array name="sort_choice">
        <item>insertion sort</item>
        <item>selection sort</item>
        <item>bubble sort</item>
        <item>quick sort</item>
    </string-array>

    <string name="linear_algo"><![CDATA[
(Linear Search) LINEAR(DATA, N, ITEM, LOC)<br/>
Here DATA is Linear Array with N elements,<br/>
and ITEM is a given item of information. This<br/>
Algorithm finds the location LOC of ITEM in<br/>
DATA, or sets LOC:=0 if the search is unsuccessful.

<br/><br/>
1.Repeat for LOC:= 1 to N by 1<br/><br/>
2. if DATA[LOC]= ITEM<br/><br/>
   \t\t    a. return LOC<br/><br/>
   \t\t    [End of loop.]<br/><br/>
3.Set LOC :=0.<br/><br/>
4.Exit.
]]></string>
    <string name="binary_algo"><![CDATA[
 (Binary Search) BINARY(DATA, LB, UB, ITEM, LOC)<br/>
 Here DATA is a sorted array with lower bound LB and uppers bound UB,<br/>
  and ITEM is given item of information. The variables BEG,<br/>
  END and MID denote respectively, the beginning, end a <br/>
   locations of a segment of elements of DATA. This algorithms <br/>
finds the location LOC of ITEM in DATA or sets DATA=NULL<br/><br/>
[Initialize Segment Variables.]<br/><br/>
1.Set BEG:= LB, END:= UB and MID:=(INT(BEG+END)/2).<br/><br/>
2.Repeat Steps 3 and 4 while BEG < END and DATA[MID]!= iTEM.<br/><br/>
3.if ITEM < DATA[MID], than:<br/><br/>
   \t\t    Set END := MID-1.<br/><br/>
  Else<br/><br/>
     \t\t   Set BEG:= MID+1<br/><br/>
  [End of lf structure.]<br/><br/>
4.  Set MID:=(INT(BEG+END)/2).<br/><br/>
 [End of Step 2 loop.]<br/><br/>
5.if DATA[MID] := ITEM, than:<br/><br/>
  \t\t     Set LOC := MID<br/><br/>
Else<br/><br/>
   \t\t    Set LOC := NULL<br/><br/>
6.Exit
]]></string>
    <string name="get_at_algo"><![CDATA[
 (GET_AT) GET_AT(A,N,ITEM,I)<br/>
        here A is a linear Array with N elements.<br/>this algorithm will return ITEM at index I.<br/><br/>
1.if I < = N and I > 0<br/><br/>
 \t\t      Set ITEM := A [ I ]<br/><br/>
2.Exit
]]></string>

    <string name="insert_algo"><![CDATA[
(Insertion Sort) INSERTION(A,N)<br/>
This Algorithms sorts the array A with N elements.<br/><br/>

1. 	Repeat Step 2 to 5 for k:=2 to N:<br/><br/>
2.		Set TEMP := A[K] and PTR := K-1<br/><br/>
3. 		Repeat while PTR>0 and TEMP < A[PTR]:<br/><br/>
		    \t\t        (a)  Set A[PTR+1] := A[PTR]. [Moves element forward.]<br/><br/>
		 \t\t           (b)  Set PTR:= PTR-1.<br/><br/>
4. 		Set A[PTR+1] := TEMP. [Inserts elements in proper places.]<br/><br/>
5.	Exit.<br/><br/>

]]></string>
    <string name="bubble_algo"><![CDATA[
    	(Bubble Sort)	BUBBLE(DATA, N)<br/>
			Here DATA is an array with N elements. This <br/>algorithm sorts the elements in DATA.<br/><br/>

1.	Repeat Step 2 and 3 for K=1 to N-1<br/><br/>
2.		Set PTR:=1 [Initializes pas pointer PTR]<br/><br/>
3.		      Repeat while PTR  N – K: [Execute pass.]<br/><br/>
		  \t\t    (a)  If DATA[PTR] > DATA[PTR+1], than:<br/><br/>
			 \t\t   \t\t   Interchange DATA[PTR] and DATA[PTR+1].<br/><br/>
		       \t\t      [End of if Structure.]<br/><br/>
		   \t\t   (b)  Set PTR := PTR+1.<br/><br/>
	[End of inner loop.]<br/><br/>
[End of Step 1 outer loop]<br/><br/>
4.	Exit.
]]></string>
    <string name="selection_algo"><![CDATA[
     (Selection Sort) SELECTIONSORT(A, N)<br/>
	The Algorithm Sorts the Array A with N Elements.<br/><br/>

1. 	Repeat step 2 to 5 from out :=1 to N-1.<br/><br/>
2.		Set min := out.<br/><br/>
3.		Set in := out+1.<br/><br/>
4.		Repeat while in < = N.<br/><br/>
       \t\t     a.if A[in] < A[min], than:<br/><br/>
		  \t\t     \t\t       min := in.<br/><br/>
     \t\t       b.in := in+1.<br/><br/>
5.		Interchange A[out] and A[min].<br/><br/>
6.	Exit.<br/><br/>


]]></string>
    <string name="merge_algo"><![CDATA[

]]></string>
    <string name="quick_algo"><![CDATA[
   QUICKSORT.(A, S, E)<br/>
   here A is unsorted linear array with first index S and last index E.<br/>
   This algorithm sorts array A recursively in ascending order.<br/><br/>
1. if S > = E.<br/><br/>
   \t\t    return.<br/><br/>
2. Set q := PARTITION (A, S, E)<br/><br/>
3. call QUICKSORT (A, S, q - 1)<br/><br/>
4. call QUICKSORT (A, q + 1, E)<br/><br/>
<br/><br/>
 PARTITION ( A, S, E)<br/>
 here A is unsorted linear array with first index S and last index E.<br/>
 This algorithm is doing partition of array and return the index of pivot element of array A.<br/><br/>
1. Set x := A [ E ].<br/><br/>
2. Set PIVOT_INDEX := S.<br/><br/>
3. for j := S to E  by 1.<br/><br/>
   \t\t   a. if A [ j ] < = x.<br/><br/>
    \t\t   \t\t      exchange A [ PIVOT_INDEX ] with A [ j ].<br/><br/>
     \t\t   \t\t     PIVOT_INDEX := PIVOT_INDEX + 1.<br/><br/>
4. exchange A [ PIVOT_INDEX ]  with A [ E ].<br/><br/>
5. return PIVOT_INDEX.<br/><br/>


]]></string>

    <string name="insertion_algo"><![CDATA["
    (inserting into a Linear Array) INSERT(LA,N,K,ITEM)<br/>
Here LA is the linear array with N elements and K is<br/>
a positive integer such that K < = N. This algorithm<br/>
inserts an element ITEM into the Kth position in LA.<br/><br/>
1. [initialize counter.] Set J := N <br/><br/>
2. Repeat Step 3 and 4 while J > K <br/><br/>
3. [Move Jth element downward.] Set LA [ J+1 ] := LA [J].<br/><br/>
4. [Decrease counter.] Set J := j-1.<br/><br/>
[End of Step 2 Loop]<br/><br/>
5.[insert element.] Set LA [K] := ITEM.<br/><br/>
6.[Reset N.] Set N:=N + 1.<br/><br/>
7.exit<br/><br/>
"
    ]]></string>
    <string name="deletion_algo"><![CDATA["
    Algorithm 4.3: (Deleting from a Linear Array) DELETE(LA, N, K, ITEM)<br/>
    Here LA is a linear array with N elements and K is a positive integer such<br/>
     that K < = N. This algorithm deletes the Kth element from LA.<br/><br/>
    1. Set ITEM :=LA[K].<br/><br/>
    2. Repeat for J=K to N-1:<br/><br/>
    [Move J+1st Element upward.] Set LA [J] := LA[ J+1 ].<br/><br/>
    [End of loop]<br/><br/>
    3. [Reset number N of elements in LA.] Set N := N-1.<br/><br/>
    4. Exit"
    ]]></string>

    <string name="insert_first_code"><![CDATA["
	public String insertFirst(int [] arr, int nElement , int data, int size){<br/><br/>

		if(nElement >= size)<br/>
			return \"array is full\";<br/><br/>
		<br/><br/>
		for(int i = nElement-1; i >= 0 ; i--)<br/>
		arr[i+1]=arr[i];<br/><br/>
		arr[0]=data;<br/><br/>
		nElement++;<br/><br/>
		return data +\" inserted at first \";<br/><br/>
	}//end insertFirst()"
]]></string>
    <string name="insert_last_code"><![CDATA["
   public String insertLast(int [] arr, int nElement , int data, int size) {<br/><br/>

		if(nElement >= size)<br/>
		    return \"array is full\";<br/><br/>

		arr[nElement++]=data;<br/><br/>
		return data +\" inserted at last \";<br/><br/>
	}//end insert()<br/><br/>"
]]></string>
    <string name="insert_in_sorted_code"><![CDATA["
public String insertInSorted(int [] arr, int nElement , int data , int size){<br/><br/>

		if(nElement >= size)<br/>
			return \"array is full\";<br/><br/>
		int i=nElement-1;<br/><br/>
		try {<br/><br/>
			while (i >= 0 && data < = arr[i] ) {<br/>
				arr[i + 1] = arr[i];<br/>
				i--;<br/>
			}<br/><br/>
			arr[i + 1] = data;<br/><br/>
			nElement++;<br/><br/>
			return data + \" inserted in sorted array \";<br/><br/>
		}catch (IndexOutOfBoundsException e){<br/><br/>
			return e.getMessage();<br/><br/>
		}<br/><br/>
	}//end insertInSorted()<br/><br/>"
]]></string>
    <string name="insert_at_code"><![CDATA["
	public String insert(int [] arr, int nElement , int data , int size , int i) {<br/><br/>

		if(nElement >= size)<br/>
		    return \"array is full\";<br/><br/>
		if(i > nElement || i < 0) <br/>
			return \"invalid index\";<br/><br/>


		for(int j = nElement-1 ; j >= i ; j--)<br/>
			arr[j+1]=arr[j];<br/><br/>
		arr[i]=data;<br/><br/>
		nElement++;<br/><br/>
		return data +\" inserted at \" +i+\"th index\";<br/><br/>
	}//end insert()<br/><br/>"

]]></string>

    <string name="delete_first_code"><![CDATA["
public String deleteFirst(int [] arr, int nElement ){<br/><br/>
		if(nElement == 0)<br/>
			return \"array is empty\" ;<br/><br/>

		int data= arr[0];<br/><br/>
		for (int i = 0 ; i < nElement ;i++)<br/>
			arr[i]=arr[i+1];<br/><br/>
		nElement--;<br/><br/>
		return data +\" is deleted \";<br/><br/>
	}//end deleteFirst()<br/><br/>"
]]></string>
    <string name="delete_last_code"><![CDATA[

"	public String deleteLast(int [] arr, int nElement){<br/><br/>
		if(nElement == 0)<br/>
			return "array is empty" ;<br/><br/>

		int data= arr[nElement-1];<br/><br/>
		nElement--;<br/><br/>
		return data +\" is deleted\";<br/><br/>
	}//end deleteLast()<br/><br/>
 "  ]]></string>
    <string name="delete_item_code"><![CDATA[
"	public String delete(int [] arr, int nElement , int data) {<br/><br/>
		if(data.equals(\"\"))<br/>
			return \"null data\";<br/><br/>
		if(nElement == 0)<br/>
			return \"array is empty\";<br/><br/>

			Integer index=null;<br/><br/>
		for(int i = 0 ;i < nElement ;i++) {<br/><br/>
			if (data == arr[i]) {<br/>
				index = i;<br/><br/>
				break;<br/><br/>
			}<br/><br/>
		}<br/><br/>
		if(index == null)<br/>
			return \"didn\'t find this data in array\";<br/><br/>

		for(int j = index ; j < nElement-1 ;j++)<br/>
			arr[j]=arr[j+1];<br/><br/>
		nElement--;<br/><br/>
		return data.toString()+\" is deleted\";<br/><br/>
	}//end delete()<br/><br/>
"]]></string>
    <string name="delete_at_code"><![CDATA[
"
	public String deleteAt(int [] arr, int nElement , int i) { <br/><br/>
		if(nElement == 0)<br/>
			return \"array is empty\" ; <br/><br/>
		if(i > nElement-1|| i < 0) <br/>
			return \"invalid index\" ;<br/><br/>

		int data = arr[i];<br/><br/>
		for(int j = i ; j < nElement-1 ;j++)<br/>
			arr[j] = arr[j+1];<br/><br/>
		nElement--;<br/><br/>
		return data +\" deleted from "+i+"th index\";<br/><br/>
	}//end deleteAt()<br/><br/>
"]]></string>

    <string name="get_at_code"><![CDATA[
"		public String getAt(int [] arr, int nElement , int index) {<br/><br/>
		if(nElement == 0)<br/>
			return \"array is empty\";<br/><br/>

		if(index > nElement-1 || index < 0)<br/>
			return \"invalid index\";<br/><br/>

		return arr[index]+\" at "+index+"th index\";<br/><br/>
	}//end getAt()<br/><br/>
"]]></string>

    <string name="linear_search_code"><![CDATA[

	public String search(int [] arr, int nElement ,int data ) {<br/><br/>

		\t Integer index=null;<br/><br/>
		\t for(int i = 0 ; i < nElement ;i++) {<br/><br/>
		\t\t	if(data == arr[i]){<br/>
			\t\t\t	index = i;<br/><br/>
		\t\t\t		break;<br/><br/>
			\t\t	}<br/><br/>
	\t	}<br/><br/>
		\t if(index == null)<br/>
		\t\t return \"data is not available\";<br/><br/>

	\t	return data +\" searched at \"+index +\"th index\";<br/><br/>
	}//end search()<br/><br/>
]]></string>
    <string name="binary_search_code"><![CDATA[
"
	public String bSearch(int [] arr, int nElement , int item) {<br/><br/>

		int beg = 0, end = nElement-1, mid = (beg + end) / 2;<br/><br/>
		while (beg < end && arr[mid] != item) {<br/><br/>
			if ( item < arr[mid])<br/>
				end = mid - 1;<br/><br/>

			else<br/>
				beg = mid + 1;<br/><br/>

			mid = (beg + end) / 2;<br/><br/>
		} // end while loop<br/><br/>
		if ( arr[mid] != (item)<br/>
			return \"data is not available\";<br/><br/>
		else<br/>
			return arr[mid]+\" searched at \"+mid +\"th index\";<br/><br/>
	}// end bSearch()<br/><br/>
"]]></string>

    <string name="selection_sort_code"><![CDATA[
"
  public void selectionSort(int [] arr, int nElement) {<br/><br/>
		for (int i = 0; i < nElement-1; i++) {<br/><br/>
			int imin = i;<br/><br/>
			for (int j = i + 1; j < nElement; j++) {<br/><br/>
				if (arr[j] < arr[imin] )<br/>
					imin = j;<br/><br/>
			} // end in for loop<br/><br/>
			int temp = arr[imin];<br/><br/>
			arr[imin] = arr[i];<br/><br/>
			arr[i] = temp;<br/><br/>
		} // end out for loop<br/><br/>
	}// end selectionSort()<br/><br/>

"
]]></string>
    <string name="insertion_sort_code"><![CDATA[
 " public void insertionSort(int [] arr, int nElement) {<br/><br/>
		for (int  i = 1; i < nElement ;i++) {<br/><br/>

			int temp = arr[i];<br/><br/>
			int j =i-1;<br/><br/>
			while(j >= 0 && temp < arr[j]) {<br/><br/>
				arr[j+1]=arr[j];<br/><br/>
				j--;<br/><br/>
				 }//end in loop<br/><br/>
			arr[j+1]=temp;<br/><br/>
		}//end out loop<br/><br/>
	}//end insert()<br/><br/>
"]]></string>
    <string name="bubble_sort_code"><![CDATA[
 "public void bubbleSort(int [] arr, int nElement) {<br/><br/>
		for (int  i = 0; i < nElement-1 ;i++) {<br/><br/>
			for(int j = 0; j < nElement-i-1 ;j++) {<br/><br/>
				if(arr[j] > arr[j+1]){<br/>
					int temp =arr[j];<br/><br/>
					arr[j]=arr[j+1];<br/><br/>
					arr[j+1]=temp;<br/><br/>
				}//end if <br/><br/>
			}//end in for<br/><br/>
		}//end out for<br/><br/>
	}//end bubbleSort()<br/><br/>
"
]]></string>
    <string name="quick_sort_code"><![CDATA[
"public void quickSort(int [] arr, int nElement , int start,int end) {<br/><br/>

			if(start >= end)<br/>
				return;<br/><br/>

				int pivot=partition(start,end);<br/><br/>
				quickSort(start,pivot-1);<br/><br/>
				quickSort(pivot+1,end);<br/><br/>
		<br/><br/>
	}//end quickSort()<br/><br/>
	<br/><br/>
	public int partition(int [] arr , int start,int end) {<br/><br/>
		int pivot=arr[end];<br/><br/>
		int pIndex=start; <br/><br/>
		for(int i = start ;i < end;i++) {<br/><br/>
			if(arr[i] < = pivot ){<br/><br/>
				int temp=arr[i];<br/><br/>
				arr[i]=arr[pIndex];<br/><br/>
				arr[pIndex]=temp;<br/><br/>
				pIndex++;<br/><br/>
			}//end if<br/><br/>
		}//end for<br/><br/>
		int temp=arr[end];<br/><br/>
		arr[end]=arr[pIndex];<br/><br/>
		arr[pIndex]=temp;<br/><br/>
		return pIndex;<br/><br/>
"	}//end partition()<br/><br/>
]]></string>
    <string name="merge_sort_code"><![CDATA[
"public void mergeSort(){

    }//end mergeSort()

"]]></string>




    <string name="array"> <p ><b>ARRAY</b></p><![CDATA["
An array is a collection of items stored at contiguous memory locations.It can hold a fix number of items and these items should be of the same type."]]></string>











<string name="stack"><p ><b>STACK</b></p><![CDATA["
Stack is an abstract data type that serves as a collection of elements, with two main principal operations: Push, which adds an element to the collection, and. Pop, which removes the most recently added element that was not yet removed."]]></string>


    <string name="push_code"><![CDATA[
"
public String push(int item , int [] arr, int size ,int top ) {<br/><br/>
		if (top >= size)<br/>
			return \"stack is overflow\";<br/><br/>

			top++;<br/><br/>
			arr[top] = item;<br/><br/>
			return item+\" is pushed to top\";<br/><br/>

	}// end insert<br/><br/>
"
]]></string>

    <string name="pop_code"><![CDATA[
"
public String pop(int [] arr, int top ) {<br/><br/>
		if (top == -1 )<br/>
			return \"stack is underflow\";<br/><br/>

		int temp = arr[top];<br/><br/>
		top--;<br/><br/>
		return temp+\" piped form top\";<br/><br/>
	}<br/><br/>

"
]]></string>

    <string name="peak_code"><![CDATA[
"
public String peak(int [] arr , int top) {<br/><br/>
		if (top == -1) <br/>
            return \"stack is underflow\";<br/><br/>

		return arr[top] +\" is top of stack\";<br/><br/>
	}<br/><br/>
"
]]></string>














    <string name="queue"><p ><b>QUEUE</b></p><![CDATA["
Queue is an abstract data type that serves as a collection of items in which only the earliest added item may be accessed. Basic operations are add (to the tail) or enqueue and delete (from the head) or dequeue."]]></string>




    <string name="deq_code"><![CDATA[
"
public String dequeue(int [] arr , int front , int rear , int size ) {<br/><br/>
		if (front == -1 )<br/>
			return \"queue is empty\";<br/><br/>
<br/><br/>
		int item = arr[front];<br/><br/>
		if ( front == rear )<br/>
			rear = front = -1;<br/><br/>
		else if (front == size - 1)<br/>
			front = 0;<br/><br/>
		else<br/>
			front++;<br/><br/>
		return item+\" is deleted from front of queue\";<br/><br/>
	}
"
]]></string>
    <string name="enq_code"><![CDATA[
"
public String enqueue(int item , int [] arr , int front , int rear , int size) {<br/><br/>
		if (front ==0 && rear == size-1 || front == rear+1)<br/>
			return \"queue is full\";<br/><br/>
		else {<br/>
			if (front == -1)<br/>
				rear = front = 0;<br/><br/>
			else if (rear == size - 1)<br/>
				rear = 0;<br/><br/>
			else<br/>
				rear++;<br/><br/>
			arr[rear] = item;<br/><br/>
			return item +\" is inserted at last of queue\";<br/><br/>
		} // else
	}// end enqueue()
"
]]></string>

    <string name="front_code"><![CDATA[
"
public String front() {<br/><br/>
		if (front == -1)<br/>
		return \"queue is empty\";<br/><br/>

		return arr[front]+\" front of queue\";<br/><br/>
	}<br/><br/>
"
]]></string>


    <string name="deq_algo"><![CDATA[
"
QDELETE(QUEUE, N, FRONT, REAR, ITEM)<br/>
			This procedure deletes an element from a queue and<br/>
			assigns it to the variable ITEM<br/><br/>

	1.	[Queue already empty?]<br/><br/>
		If FRONT := NULL, then:<br/><br/>
			Write : “Queue Empty”, and Return.<br/><br/>
	2.	Set ITEM := QUEUE[FRONT].<br/><br/>
	3.	[Find New Value of FRONT.]<br/><br/>
	  	If  FRONT = REAR,   then: 	[if Queue has only one element to start.]<br/><br/>
			Set FRONT:= NULL and REAR = NULL.<br/><br/>
		Else if FRONT = N, then:<br/><br/>
			Set FRONT := 1;<br/><br/>
		Else:<br/><br/>
			Set FRONT := FRONT+1.<br/><br/>
		[End of If Structure.]<br/><br/>
	4.	Return.<br/><br/>

"
]]></string>
    <string name="enq_algo"><![CDATA[
"
QINSERT(QUEUE,N,FRONT,REAR,ITEM)<br/>
			This procedure inserts an element ITEM into a queue.<br/><br/>

	1.	[check if Queue already filled ?]<br/><br/>
		if FRONT=1 and REAR = N, or if FRONT=REAR+1, then:<br/><br/>
			Write: “Over Flow ”, and Return.<br/><br/>
	2.	[Find new value of REAR.]<br/><br/>
		If FRONT := NULL, then:<br/><br/>
			Set FRONT:=1 and REAR:=1.<br/><br/>
		Else if REAR=N, then :<br/><br/>
			Set REAR :=1.<br/><br/>
		Else<br/><br/>
			Set REAR := REAR+1.<br/><br/>
		[End of If Structure.]<br/><br/>

	3.	Set QUEUE[REAR] := ITEM.   [Insert New Element.]<br/><br/>
	4.	Return.<br/><br/>

"
]]></string>

    <string name="front_algo"><![CDATA[
"

 FRONT(QUEUE, FRONT, ITEM)<br/>
		This procedure returns the FRONT element of QUEUE without<br/>
			removing and assignees it to the variable ITEM.<br/><br/>

1.		[ If QUEUE is Empty?]<br/><br/>
		If FRONT = 0, than:<br/><br/>
		Print: QUEUE is Empty, and Return.<br/><br/>
2.		Set ITEM:= QUEUE[FRONT]. [Assigns FRONT element to ITEM.]<br/><br/>
3.		Return.<br/><br/>
"
]]></string>



    <string name="push_algo"><![CDATA[
"
PUSH(STACK, TOP, LEN, ITEM)<br/>
		        This procedure pushes an ITEM onto a stack.<br/><br/>

1.	If TOP = LEN, then:<br/><br/>
	   Print: Stack is Full, and Return. [Stack already filled ?]<br/><br/>
2.	Set TOP := TOP+1. [Increases TOP by 1.]<br/><br/>
3.	Set STACK[TOP] := ITEM. [Insert ITEM in new TOP position.]<br/><br/>
4.	Return.<br/><br/>


"
]]></string>

    <string name="pop_algo"><![CDATA[
"
POP(STACK, TOP, ITEM)<br/>
		This procedure deletes the top element of STACK <br/>	and assignees it to the variable ITEM.<br/><br/>

1.		[ If Stack has no item to removed?]<br/><br/>
		If TOP = 0, than:<br/><br/>
	        	Print: Stack is Empty, and Return.<br/><br/>
2.		Set ITEM:= STACK[TOP]. [Assigns TOP element to ITEM.]<br/><br/>
3.		Set TOP := TOP-1. [Decreases TOP by 1.]<br/><br/>
4.		Return.<br/><br/>

"
]]></string>

    <string name="peak_algo"><![CDATA[
"
 PEEK(STACK, TOP, ITEM)<br/>
		This procedure returns the top element of STACK without <br/>	removing and assignees it to the variable ITEM.<br/><br/>

1.		[ If Stack is Empty?]<br/><br/>
		If TOP = 0, than:<br/><br/>
		Print: Stack is Empty, and Return.<br/><br/>
2.		Set ITEM:= STACK[TOP]. [Assigns TOP element to ITEM.]<br/><br/>
3.		Return.<br/><br/>

"
]]></string>






    <string name="linkedlist"><p ><b>LINKED LIST</b></p><![CDATA["
A linked list is a linear collection of data elements whose order is not given by their physical placement in memory. Instead, each element points to the next. It is a data structure consisting of a collection of nodes which together represent a sequence."]]></string>


    <string name="insertfirst_list_code"><![CDATA[
	public  String insertFirst(node start , node end , int item) {<br/><br/>
	\t	node  temp = new node (item);<br/><br/>
	\t		if (start == null) <br/>
	\t	\t			end = temp;<br/><br/>
		\t	 else <br/>
		\t	\t		start.prev = temp;<br/><br/>

			\t temp.next = start;<br/><br/>
			\t start = temp;<br/><br/>
	\t		return item +\" is inserted at first\";<br/><br/>
	}//end insertFirst()<br/><br/>

]]></string>

    <string name="insertlast_list_code"><![CDATA[
	public String insertLast(node start , node end , int item) {<br/><br/>
	\t	node  temp = new node (item);<br/><br/>
	\t		if (start == null) <br/>
	\t	\t			start = temp;<br/><br/>
		\t	 else <br/>
		\t	\t		end.next = temp;<br/><br/>

			\t temp.prev = end;<br/><br/>
			\t end = temp;<br/><br/>
	\t		return item +\" is inserted at first\";<br/><br/>
	}//end insertLast()<br/><br/>

]]></string>


    <string name="insertion_list_code"><![CDATA[
"

	public String insertAt(node start ,node end ,int index, int item) {<br/><br/>
		node  temp = new node(item);<br/><br/>

		if (start == null) {<br/><br/>
			start = temp;<br/><br/>
			end = temp;<br/><br/>
			return item +\" is inserted at \"+index+\"th index\";<br/><br/>
		}<br/><br/>

        current = start ;
		 for(int i=0 ; i < index ; i++){<br/><br/>
		if(current==null)<br/>
		     break;<br/><br/>
		current = current.next;<br/><br/>
		}<br/><br/>


       if (current == start ){<br/><br/>
            temp.next  = start;<br/><br/>
            start.prev = temp<br/><br/>
            start = temp;<br/><br/>
         }<br/><br/>

       else if(current == null ){ <br/><br/>
            temp.prev =  end;<br/><br/>
            end.next = temp;<br/><br/>
            end= temp;<br/><br/>
         }<br/><br/>
      else{<br/><br/>
            temp.next = current;<br/><br/>
            temp.prev = current.prev;<br/><br/>
            current.prev.next = temp;<br/><br/>
            current.prev=temp;<br/><br/>
            }<br/><br/>



		return item +\" is inserted at "+index+"th index\";<br/><br/>
	}//end insertAt()<br/><br/>


"
]]></string>


    <string name="insert_in_list_code"><![CDATA[
"

	public String insertIn(node start, node end ,int item) {<br/><br/>
		node  temp = new node (item);<br/><br/>
		if (start == null) {<br/><br/>
			start = temp;<br/><br/>
			end = temp;<br/><br/>
			return item +\" is inserted in sorted list\";<br/><br/>
		}<br/><br/>

		node  curr = start;<br/><br/>
		while (curr != null && curr.data < = item )  {<br/><br/>
			curr = curr.next;<br/><br/>
		}<br/><br/>
		if (curr == null) {<br/><br/>
			temp.prev = end;<br/><br/>
			end.next = temp;<br/><br/>
			end = temp;<br/><br/>
			return item +\" is inserted in sorted list\";<br/><br/>
		}<br/><br/>
		if (curr == start)<br/>
			start = temp;<br/><br/>
		temp.next = curr;<br/><br/>
		temp.prev = curr.prev;<br/><br/>
		if (curr.prev != null)<br/>
			curr.prev.next = temp;<br/><br/>
		curr.prev = temp;<br/><br/>
		return item +\" is inserted in sorted list\";<br/><br/>
	}//end insertIn()

"
]]></string>


    <string name="deletefirst_list_code"><![CDATA[
"

	public String deleteFirst(node start , node end) {<br/><br/>
		if (start == null)<br/>
			return \"list is empty\";<br/><br/>


		 int data = start.data;<br/><br/>
		 	if (start == end){<br/>
			end = null; <br/>
			start = null; <br/>
			return data+\" is deleted from first of LinkedList\"; <br/>

			}<br/><br/>
			
		start = start.next;<br/><br/>
		start.prev = null;<br/><br/>

		 return data+\" is deleted from first of LinkedList\";<br/><br/>
	}//end deleteFirst()
"
]]></string>


    <string name="deletelast_list_code"><![CDATA[
"
	public String deleteLast(node start , node end) {<br/><br/>
		if (start == null)<br/><br/>
			return \"list is empty\";<br/><br/>

		 int data = end.data;<br/><br/>
		 	if (start == end){<br/>
			start = null;<<br>
			end = null;<br/>
			return data+\" is deleted from last of LinkedList\";<br/>
			}<br/><br/>
		end = end.prev;<br/><br/>
		end.next = null;<br/><br/>

		return data+\" is deleted from last of LinkedList\";<br/><br/>
	}//end deleteLast()


"
]]></string>

    <string name="deletion_list_code"><![CDATA[
"
public String delete(node start , node end , int item) {<br/><br/>
		if (start == null )<br/>
		return  \"list is empty\";<br/><br/>
        node current = start;<br/><br/>
        while (current.data != item ){<br/><br/>
         if(current.next == null )<br/>
            return item+\" is not found\";<br/><br/>
         current = current.next;<br/><br/>
            }<br/><br/>
        if (current == start )<br/>
             start = current.next;<br/><br/>
        else <br/>
            current.prev.next = current .next;<br/><br/>
        if(current == end ) <br/>
            end= current.prev;<br/><br/>
        else <br/>
            current.next.prev = current.prev;<br/><br/>

		return  item +\" is deleted\";<br/><br/>
	}//end delete()

"
]]></string>

    <string name="delete_at_list_code"><![CDATA[
"
	public String  deleteAt( int index , node start , node end ) { <br/><br/>
		if (start == null )<br/>
			return \"list is empty\";<br/><br/>
    node  current = start; <br/><br/>
    for(int i=0 ; i < index ; i++){<br/><br/>
		if(current.next==null)<br/>
		 return item+\" is not found\";<br/><br/>
		current = current.next;<br/><br/>
		}<br/><br/>


   if (current == first )<br/>
             first = current.next;<br/><br/>
        else <br/>
            current.prev.next = current .next;<br/><br/>
        if(current == last ) <br/>
            last= current.prev;<br/><br/>
        else <br/>
            current.next.prev = current.prev;<br/><br/>



		return item+\" is deleted from index \"+index+\"th\";<br/><br/>

	}//end deleteAt()<br/><br/>


"
]]></string>



    <string name="search_list_code"><![CDATA[
"
public node  search(node start , int item) {<br/><br/>
		if (start == null) <br/>
			return "list is empty";<br/><br/>

		node  temp = start;<br/><br/>
		while (temp.data != item) {<br/><br/>

			if (temp.next == null) <br/>
				return null;<br/><br/>

			temp = temp.next;<br/><br/>
		}<br/><br/>
		return temp;<br/><br/>
	}//end search()<br/><br/>
"
]]></string>

    <string name="sort_list_code"><![CDATA[
"
public void insertionSort(node start) {<br/><br/>
		if (start == null)<br/>
			return;<br/><br/>


		node  curr = start;<br/><br/>
		start = null;<br/><br/>
		while (curr != null) {<br/><br/>
			insertIn(curr.data);<br/><br/>
			curr = curr.next;<br/><br/>
		}<br/><br/>

	}//end insertionSort()<br/><br/>


	public void insertIn(node start) {<br/><br/>
		node  temp = new node (item);<br/><br/>
		if (start == null) {<br/><br/>
			start = temp;<br/><br/>
			end = temp;<br/><br/>
			return ;<br/><br/>
		}<br/><br/>

		node  curr = start;<br/><br/>
		while (curr != null && curr.data < = item ) <br/>
			curr = curr.next;<br/><br/>

		if (curr == null) {<br/><br/>
			temp.prev = end;<br/><br/>
			end.next = temp;<br/><br/>
			end = temp;<br/><br/>
			return ;<br/><br/>
		}<br/><br/>
		if (curr == start)<br/>
			start = temp;<br/><br/>
		temp.next = curr;<br/><br/>
		temp.prev = curr.prev;<br/><br/>
		if (curr.prev != null)<br/>
			curr.prev.next = temp;<br/><br/>
		curr.prev = temp;<br/><br/>
		return ;<br/><br/>
	}//end insertIn()
"
]]></string>

    <string name="get_at_list_code"><![CDATA[
"

	public node  getAt(node start, int index) {<br/><br/>
		if (start == null )<br/>
			return null;<br/><br/>

		int i = 0;<br/><br/>
		node  temp = start;<br/><br/>
		while (temp.next != null && i < index) {<br/><br/>
			temp = temp.next;<br/><br/>
			i++;<br/><br/>
		}<br/><br/>
		return temp;<br/><br/>
	}//end getAt()<br/><br/>

"
]]></string>






    <string name="insertfirst_list_algo"><![CDATA[
"
 INSERTFIRST( FIRST, LAST, ITEM) <br/>
This algorithm inserts ITEM as the first node in a doubly<br/>
linked list  LIST.<br/><br/>

1.	Set  DATA[NEWLINK] = ITEM;	[create new link.]<br/><br/>
2.	if FIRST = NULL, than:		[If Empty List.]<br/><br/>
		Set LAST := NEWLINK.		[newLink < -- last.]<br/><br/>
	Else<br/><br/>
		Set PREVIOUS[FIRST] := NEWLINK.  [NEWLINK < -- OLD FIRST.]<br/><br/>
	[End of If Structure.]<br/><br/>

3.	Set NEXT[NEWLINK] := FIRST.	[ NEWLINK --> OLD FIRST.]<br/><br/>
4. 	Set FIRST = NEWLINK.		[ FIRST --> NEWLINK.]<br/><br/>
5.	Exit.<br/><br/>


"
]]></string>

    <string name="insertlast_list_algo"><![CDATA[
"
 INSERTLAST( FIRST, LAST, ITEM) <br/>
This algorithm inserts ITEM as the last node in a doubly<br/>
linked list  LIST.<br/><br/>

1.	Set  DATA[NEWLINK] = ITEM;	[create new link.]<br/><br/>
2.	if FIRST = NULL, than:		[If Empty List.]<br/><br/>
		Set FIRST := NEWLINK.		[newLink < -- FIRST.]<br/><br/>
	Else<br/><br/>
		Set NEXT[LAST] := NEWLINK.  [NEWLINK < -- OLD LAST.]<br/><br/>
	[End of If Structure.]<br/><br/>

3.	Set PREVIOUS[NEWLINK] := LAST.	[ NEWLINK --> OLD LAST.]<br/><br/>
4. 	Set LAST = NEWLINK.		[ LAST --> NEWLINK.]<br/><br/>
5.	Exit.<br/><br/>


"
]]></string>


    <string name="insertion_list_algo"><![CDATA[


"
 INSERT( FIRST, LAST, ITEM,INDEX) <br/>
This algorithm inserts ITEM at index INDEX in a doubly<br/>
linked list  LIST.<br/><br/>

1.	Set  DATA[NEWLINK] = ITEM;	[create new link.]<br/>
2.	if FIRST = NULL, than:		[If Empty List.]<br/>
	\t\t\t\t\t\t	Set FIRST := NEWLINK.		[newLink < -- FIRST.]<br/>
	\t\t\t\t\t\t	Set LAST := NEWLINK.<br/>
	\t\t\t\t\t\t	return.<br/><br/>
3. Set CURRENT := FIRST<br/>
4. repeat for i:= 0 to INDEX by 1.<br/>
   \t\t\t\t\t\t     a.if CURRENT := NULL, than:<br/>
   \t\t\t\t\t\t\t\t\t\t\t\t         break.<br/>
  \t\t\t\t\t\t      b.Set CURRENT := NEXT[CURRENT].<br/><br/>
5. if CURRENT = FIRST , than:<br/>
    \t\t\t\t\t\t    PREVIOUS [ NEWLINK ] := LAST.<br/>
    \t\t\t\t\t\t    NEXT [FIRST] := NEWLINK.<br/>
    \t\t\t\t\t\t    FIRST := NEWLINK.<br/><br/>
    else if CURRENT = NULL, then :<br/>
    \t\t\t\t\t\t    NEXT [ NEWLINK ] := FIRST.<br/>
    \t\t\t\t\t\t    PREVIOUS [LAST] := NEWLINK.<br/>
    \t\t\t\t\t\t    END := NEWLINK.<br/><br/>
    else<br/>
    \t\t\t\t\t\t    NEXT [ NEWLINK ] := CURRENT.<br/>
    \t\t\t\t\t\t    PREVIOUS [ NEWLINK ] := PREVIOUS [CURRENT].<br/>
    \t\t\t\t\t\t    NEXT [PREVIOUS [CURRENT]]:= NEWLINK.<br/>
    \t\t\t\t\t\t    PREVIOUS [CURRENT] := NEWLINK<br/><br/>
6. return.

"

]]></string>


    <string name="insert_in_list_algo"><![CDATA[
"


"
]]></string>


    <string name="deletefirst_list_algo"><![CDATA[
"


"
]]></string>


    <string name="deletelast_list_algo"><![CDATA[
"


"
]]></string>

    <string name="deletion_list_algo"><![CDATA[
"
DELETE(LIST, FIRST,LAST, ITEM, LOC)<br/>
This algorithm deletes from a linked list the first node <br/>
N which contains the given ITEM of information.<br/><br/>
1.	Set CURRENT  := FIRST.<br/><br/>
2.	if CURRENT=NULL, than:			[If List is empty.]<br/><br/>
		a) LOC := NULL.<br/><br/>
		b) Print "List Empty" and return.<br/><br/>
3.	Repeat while DATA[CURRENT] ≠ ITEM:		[ Search for link.]<br/><br/>
		If NEXT[CURRENT] = NULL, than:<br/><br/>
		   Print “Item not found” return NULL.	[Didn't find it.]<br/><br/>
4.	If CURRENT=FIRST, than:		 	[ first item?.]<br/><br/>
		Set FIRST = NEXT[CURRENT] 		[ first --> old next.]<br/><br/>
	Else 			[if not first than:  old previous --> old next.]<br/><br/>
		Set NEXT[PREVIOUS[CURRENT]] := NEXT[CURRENT]. <br/><br/>
5.	If CURRENT=LAST, than:		[ last item?]<br/><br/>
		Set LAST = CURRENT;		[ old previous < -- last.]<br/><br/>
	else			[ not last than   old previous < -- old next.]<br/><br/>
		Set  PREVIOUS[NEXT[CURRENT]] := .PREVIOUS[CURRENT]<br/><br/>
"
]]></string>

    <string name="delete_at_list_algo"><![CDATA[
"


"
]]></string>



    <string name="search_list_algo"><![CDATA[
"
 SEARCH( START, ITEM, LOC)<br/>
	Here LIST is a linked list in memory. This algorithm finds the <br/>node LOC where ITEM first appears in LIST, or sets LOC :=NULL.<br/><br/>

1.	Set PTR := START.<br/><br/>
2.	Repeat while DATA[PTR] ≠ ITEM:<br/><br/>
		If  NEXT[PTR] = NULL, then: 		[ If end of list.]<br/><br/>
			Set LOC := NULL, and Exit. 	[ Didn't find it.] <br/><br/>
 		Else:<br/><br/>
			Set PTR := NEXT[PTR]. [PTR now points to the next node.]<br/><br/>
		[End of if Structure.]<br/><br/>
	[End of Step 2 Loop.] <br/><br/>
3.	Set LOC := PTR.		[If Search is successful.]<br/><br/>
4.	Exit.<br/><br/>


"
]]></string>

    <string name="sort_list_algo"><![CDATA[
"


"
]]></string>

    <string name="get_at_list_algo"><![CDATA[
"
(GET_AT) GET_AT(DATA , START ,ITEM,INDEX)<br/>
        this algorithm will return ITEM at index INDEX in list DATA.<br/><br/>
1. Set ITEM := START and  i := 1 .<br/><br/>

2. repeat while ITEM.next != null and i < INDEX:<br/><br/>
  \t\t  a.ITEM := next[ITEM].<br/><br/>
   \t\t     b.i := i + 1.<br/><br/>
3.return ITEM.<br/><br/>

"
]]></string>











    <string name="tree"><p ><b>TREE</b></p><![CDATA["
A tree is a abstract data type that simulates a hierarchical tree structure, with a root value and subtrees of children with a parent node, represented as a set of linked nodes."]]></string>



    <string name="insertion_tree_code"><![CDATA[
    "
   public String insert(Node root, int item) {<br/><br/>
   \t\t         Node   temp = new Node (item);<br/><br/>
    \t\t        if(root == null) {<br/><br/>
     \t\t\t\t           root=temp;<br/><br/>
     \t\t\t\t           return item +\" is inserted\";<br/><br/>
            \t\t }<br/><br/>

    \t\tNode  cur=root;<br/><br/>
    \t\twhile(cur!=null) {<br/><br/>
        \t\t\t\tNode   parent=cur;<br/><br/>
        \t\t\t\tif(item < cur.data)<br/><br/>
        \t\t\t\t\t\t{<br/><br/>
            \t\t\t\t\t\tcur=cur.left;<br/><br/>

        \t\t\t\t\t\tif(cur==null) {<br/><br/>
            \t\t\t\t\t\tparent.left=temp;<br/><br/>
            \t\t\t\t\t\tparent.left.isLeft=true;<br/><br/>
       \t\t\t\t \t\t\t\t}<br/><br/>
       \t\t\t\t }//end if<br/><br/>
       \t\t\t\t else {<br/><br/>
            \t\t\t\t\t\tcur=cur.right;<br/><br/>

        \t\t\t\t\t\tif(cur==null) {<br/><br/>
          \t\t\t\t  \t\t\t\t parent.right=temp;<br/><br/>
       \t\t\t\t   \t\t\t\t  parent.right.isLeft=false;<br/><br/>
       \t\t\t\t\t\t }<br/><br/>
   \t\t\t\t }//end else<br/><br/>
    \t\t\t\t}//end while()<br/><br/>
        \t\treturn item +\" is inserted\";<br/><br/>
    }//end insert()<br/><br/>
    "]]></string>

    <string name="search_tree_code"><![CDATA["

public String search(Node root , int item) {<br/><br/>

		Node  cur=root;<br/><br/>
		while(cur.data!=item) {<br/><br/>

			if(item < cur.data) <br/>
				cur=cur.left;<br/><br/>
			else <br/>
				cur=cur.right;<br/><br/>


			if(cur==null)<br/>
				return item +\" is not found in tree\";<br/><br/>
		}//end while()<br/><br/>
		return item +\" is found in tree\";<br/><br/>
	}//end search()<br/><br/>

  "
    ]]></string>
    <string name="deletion_tree_code"><![CDATA[

    "
    this code is different from algorithm <br/><br/>
    public String delete(Node root, int item) {<br/><br/>
		if(root == null)<br/>
			return \"Tree is empty\";<br/><br/>

		Node  curr= root;<br/><br/>
		Node  parent= root ;<br/><br/>
		boolean isLeftChild=true;<br/><br/>
		while(curr.data!=item) {<br/><br/>
			parent=curr;<br/><br/>
			if(item < curr.data) {<br/><br/>
				curr=curr.left;<br/><br/>
				isLeftChild=true;<br/><br/>
			}<br/><br/>
			else {<br/><br/>
				curr=curr.right;<br/><br/>
				isLeftChild=false;<br/><br/>
			}<br/><br/>
			if(curr==null)<br/>
				return \"node not found\";<br/><br/>

		}//end while()<br/><br/>
//case 1<br/><br/>
		if(curr.left==null&&curr.right==null) {<br/><br/>
			if(curr==root)<br/>
				root=null;<br/><br/>
			else if(isLeftChild)<br/>
				parent.left=null;<br/><br/>
			else<br/>
				parent.right=null;<br/><br/>
		}//end case 1<br/><br/>

//case 2 right<br/><br/>
		if(curr.left==null&&curr.right!=null) {<br/><br/>
			if(curr==root)<br/>
				root=curr.right;<br/><br/>
			else if(isLeftChild)<br/>
				parent.left=curr.right;<br/><br/>
			else<br/>
				parent.right=curr.right;<br/><br/>
		}//end case 2 right<br/><br/>
//case 2 left <br/><br/>
		if(curr.left!=null&&curr.right==null) {<br/><br/>
			if(curr==root)<br/>
				root=curr.left;<br/><br/>
			else if(isLeftChild)<br/>
				parent.left=curr.left;<br/><br/>
			else<br/>
				parent.right=curr.left;<br/><br/>
		}//end case 2 left<br/><br/>
//case 3<br/><br/>
		if(curr.left!=null&&curr.right!=null) {<br/><br/>
			Node  min = getMin(curr.right);<br/><br/>
			curr.data=min.data;<br/><br/>

			Node temp =curr;<br/><br/>
			if(temp.right==min)<br/>
				temp.right=min.right;<br/><br/>
			else {<br/><br/>
				temp=temp.right;<br/><br/>
				while(temp.left!=min)<br/>
					temp=temp.left;<br/><br/>

			temp.left=min.right;<br/><br/>

			}<br/><br/>
		}//end case 3<br/><br/>
		return item+\" is deleted\";<br/><br/>
	}//end delete()<br/><br/><br/><br/>


public link  getMin(link  curr){<br/><br/>

		while(curr.left!=null)<br/>
			curr=curr.left;<br/><br/>

		return curr;<br/><br/>
	}
  "
    ]]></string>

    <string name="insertion_tree_algo"><![CDATA["
INSERT( ROOT, ITEM)<br/>
This Algorithm Inserts an ITEM as a node on its appropriate location in a<br/>
binary tree TREE.<br/><br/>
1. Set DATA[NEWNODE] := ITEM.<br/><br/>
2. If ROOT=NULL, than: [ no node in root.]<br/><br/>
\t\t\t\tSet ROOT:= NETNODE.<br/><br/>
Else [root occupied.]<br/><br/>
\t\t\t a) Set CURRENT:= ROOT. [start at root.]<br/><br/>
\t\t\t b) Repeat While CURRENT != NULL:<br/><br/>
\t\t\t\t\t\t\t a) Set PARENT := CURRENT.<br/><br/>
\t\t\t\t\t\t\t b) If ITEM < DATA[CURRENT], than: [ go left?]<br/><br/>
 \t\t\t\t\t\t\t\t\t\t\t\t Set CURRENT =LEFT[CURRENT].<br/><br/>
 \t\t\t\t\t\t\t\t\t\t\t\t IF CURRENT= NULL, than: [ if end of the line]<br/><br/>
\t\t\t\t\t\t\t\t\t\t\t\t Set LEFT[PARENT] := NEWNODE and Return.<br/><br/>
\t\t\t\t\t\t\t\t Else [ or go right?]<br/><br/>
\t\t\t\t\t\t\t\t\t\t\t\t Set CURRENT := RIGHT[CURRENT].<br/><br/>
 \t\t\t\t\t\t\t\t\t\t\t\t IF CURRENT=NULL, than: [ if end of the line.]<br/><br/>
\t\t\t\t\t\t\t\t\t\t\t\t Set RIGHT[PARENT] := NEWNODE and Return.<br/><br/>
3. Return.<br/><br/>
    "
    ]]></string>

    <string name="search_tree_algo"><![CDATA["

FIND(ROOT, ITEM , N)<br/>
 A binary search tree TREE is in memory and ROOT is the root of<br/>
the tree, an ITEM of information is given. This Procedure finds the<br/>
node N of ITEM in TREE , The methods returns NULL if ITEM is not<br/>
present in TREE.<br/><br/>
1. Set CURRENT := ROOT. [Start at root.]<br/><br/>
2. Repeat Step 3 and 4 while DATA[CURRENT] != ITEM: [Until Find.]<br/><br/>
3.\t\t  If ITEM < DATA[CURRENT], than: [ Go Left].<br/><br/>
\t\t\t\t\t Set CURRENT := LEFT[CURRENT].<br/><br/>
\t\t\t Else [ Or Go Right.]<br/><br/>
\t\t\t\t\t Set CURRENT = RIGHT[CURRENT]<br/><br/>
4.\t\t  If CURRENT = NULL, than: [No Child.]<br/><br/>
\t\t\t\t\t Set N := NULL. [Didn’t Find It.]<br/><br/>
5. Set N:= CURRENT. [Found It]<br/><br/>
6. Return.<br/><br/>

  "
    ]]></string>
    <string name="deletion_tree_algo"><![CDATA["
DELETE( ROOT, KEY)<br/>
This Method deletes the Node N of which has key KEY from a binary<br/>
tree TREE.<br/><br/>
1. [Initialize Pointers.]<br/><br/>
SET CURRENT := ROOT and PARENT := ROOT and<br/><br/>
ISLEFTCHILD = TRUE. [Is it the Left Leaf.?]<br/><br/>
2. Repeat until DATA[CURRENT] != KEY) [ Search for Node.]<br/><br/>
\t\t a) Set PARENT := CURRENT.<br/><br/>
\t\t b) If KEY < DATA[CURRENT], than: [ GO LEFT?]<br/><br/>
\t\t\t\t i) Set ISLEFTCHILD := TRUE.<br/><br/>
 \t\t\t\t ii) Set CURRENT:= LEFT[CURRENT].<br/><br/>
\t\tElse [ OR GO RIGHT?]<br/><br/>
\t\t\t\t i) Set ISLEFTCHILD := FALSE.<br/><br/>
 \t\t\t\t ii) Set CURRENT := RIGHT[CURRENT].<br/><br/>
 \t\t c) If CURRENT = NULL, than: [ END OF THE LINE?]<br/><br/>
\t\t\t\t Print “NODE not Found “ and RETURN. [ DIDN'T FIND IT].<br/><br/>
[ If node is found and it has no left or right child . CASE 1.]<br/><br/>

case 1: delete the leaf node<br/><br/>

3. IF LEFT[CURRENT] =NULL and RIGHT[CURRENT] =NULL, than:<br/><br/>
\t\t a) If CURRENT = ROOT, than [ IF ROOT?]<br/><br/>
\t\t\t\t Set ROOT := NULL. [ TREE IS EMPTY.]<br/><br/>
\t\t Else If ISLEFTCHILD = TRUE, than: [if it is a left child?]<br/><br/>
\t\t\t\t Set LEFT[PARENT] := NULL. [ disconnect from parent.]<br/><br/>
\t\t Else<br/><br/>
\t\t\t\t Set RIGHT[PARENT] := NULL.<br/><br/>

case 2: delete the node with one child node <br/><br/>

[ IF NO RIGHT CHILD, REPLACE WITH LEFT SUBTREE.]<br/><br/>
Else if RIGHT[CURRENT]=NULL, than:<br/><br/>
\t\t If CURRENT = ROOT, than:<br/><br/>
\t\t\t\tSet ROOT := LEFT[CURRENT].<br/><br/>
\t\t Else if ISLEFTCHILD= TRUE, than: [ LEFT CHILD OF PARENT.]<br/><br/>
\t\t\t\t Set LEFT[PARENT] := LEFT[CURRENT].<br/><br/>
\t\t Else    [RIGHT CHILD OF PARENT.]<br/><br/>
\t\t\t\t Set RIGHT[PARENT] := LEFT[CURRENT].<br/><br/>
[IF NO LEFT CHILD, REPLACE WITH RIGHT SUBTREE.]<br/><br/>
Else if LEFT[CURRENT] = NULL, than:<br/><br/>
\t\t If CURRENT = ROOT, than:<br/><br/>
\t\t\t\t Set ROOT := RIGHT[CURRENT].<br/><br/>
\t\t Else if ISLEFTCHILD= TRUE, than: [LEFT CHILD OF PARENT.]<br/><br/>
\t\t\t\t Set LEFT[PARENT] := RIGHT[CURRENT].<br/><br/>
\t\t Else [RIGHT CHILD OF PARENT.]<br/><br/>
\t\t\t\t Set RIGHT[PARENT] :=RIGHT[CURRENT].<br/><br/>

case 3: delete the node with two child node<br/><br/>

Else [two children, so replace with inorder successor.]<br/><br/>
\t\t [ get successor of node to delete (current).]<br/><br/>
\t\t Set SUCCESSOR := GETSUCCESSOR(CURRENT).<br/><br/>
\t\t [CONNECT PARENT OF CURRENT TO SUCCESSOR INSTEAD.]<br/><br/>
\t\t If CURRENT = ROOT, than:<br/><br/>
\t\t\t\t Set ROOT := SUCCESSOR.<br/><br/>
\t\t Else if ISLEFTCHILD=TRUE, than:<br/><br/>
\t\t\t\t Set LEFT[PARENT] := SUCCESSOR.<br/><br/>
\t\t Else<br/><br/>
\t\t\t\t RIGHT[PARENT] := SUCCESSOR.<br/><br/>
[ CONNECT SUCCESSOR TO CURRENT'S LEFT CHILD.]<br/><br/>
Set LEFT[SUCCESSOR.] := LEFT[CURRENT.]<br/><br/>
[ END of ELSE for TWO CHILDREN.]<br/><br/>
[ END DELETE().]<br/><br/>
<br/><br/>
GETSUCCESSOR(TREE, DELNODE, SUCCESSOR)<br/>
This Method sets a node SUCCESSOR, with next-highest value<br/>
after DELNODE, The Method goes to right child, then right child's<br/>
left descendants to find the successor of DELNODE.<br/><br/>
1. Set SUCCESSORPARENT :=DELNODE and SUCCESSOR := DELNODE and<br/><br/>
\t\tCURRENT := RIGHT[DELNODE]. [GO TO RIGHT CHILD.]<br/><br/>
2. Repeat until CURRENT ≠ NULL: [ UNTIL NO MORE.]<br/><br/>
 \t\t a) Set SUCCESSORPARENT := SUCCESSOR;<br/><br/>
 \t\t b) Set SUCCESSOR := CURRENT.<br/><br/>
 \t\t c) Set CURRENT = LEFT[CURRENT].[GO TO LEFT CHILD.]<br/><br/>
3. [ IF SUCCESSOR NOT RIGHT CHILD.]<br/><br/>
IF SUCCESSOR ≠ RIGHT[DELNODE], than:[ MAKE CONNECTIONS.]<br/><br/>
\t\t a) Set LEFT[SUCCESSORPARENT] := RIGHT[SUCCESSOR.]<br/><br/>
 \t\t b) Set RIGHT[SUCCESSOR] := RIGHT[DELNODE.]<br/><br/>
"
    ]]></string>


    <string name="inorder_tree_code"> <![CDATA["
    public void inorder(node curr) {<br/><br/>
		if(curr==null)<br/><br/>
			return;<br/><br/>
		inorder(curr.left);<br/><br/>
		System.out.print(curr.data +\" \");<br/><br/>
		inorder(curr.right);<br/><br/>
	}//end inorder()<br/><br/>




    "
    ]]></string>

    <string name="inorder_tree_algo"> <![CDATA["
 INORDER( LOCALROOT)<br/>
A Binary tree TREE is in memory. This procedure does<br/>
an inorder traversal of TREE applying an operation<br/>
PROCESS to each of its nodes.<br/><br/>
Step 1. if LOCALROOT ≠ NULL, than:<br/><br/>
 Call INORDER(LEFT[LOCALROOT]. [Visit Left Child.]<br/><br/>
 Apply PROCESS to LOCALROOT. [Apply Process to Node.]<br/><br/>
 Call INORDER(RIGHT[LOCALROOT]. [Visit Right Child.]<br/><br/>
Set 2. Return.<br/><br/>
    "
    ]]></string>

    <string name="preorder_tree_code"> <![CDATA["
    	public void preorder(node curr) {<br/><br/>
		if(curr==null)<br/><br/>
			return;<br/><br/>
		System.out.print(curr.data +\" \");<br/><br/>
		inorder(curr.left);<br/><br/>
		inorder(curr.right);<br/><br/>
	}//end inorder()<br/><br/>

    "
    ]]></string>

    <string name="preorder_tree_algo"> <![CDATA["
PREORDER( LOCALROOT )
A Binary tree TREE is in memory. This procedure does<br/>
an preOrder traversal of TREE applying an operation<br/>
PROCESS to each of its nodes.<br/><br/>
Step 1. if LOCALROOT != NULL, than:<br/><br/>
 Apply PROCESS to LOCALROOT. [Visit the Node.]<br/><br/>
 Call PREORDER(LEFT[LOCALROOT]. [Visit Left Child.]<br/><br/>
 Call PREORDER(RIGHT[LOCALROOT]. [Visit Right Child.]<br/><br/>
Set 2. Return.<br/><br/>
    "
    ]]></string>

    <string name="postorder_tree_code"> <![CDATA["
    	public void postorder(node   curr) {<br/><br/>
		if(curr==null)<br/><br/>
			return;<br/><br/>
		inorder(curr.left);<br/><br/>
		inorder(curr.right);<br/><br/>
		System.out.print(curr.data +\" \");<br/><br/>
	}//end inorder()<br/><br/>
    "
    ]]></string>

    <string name="postorder_tree_algo"> <![CDATA["
POSTORDER( LOCALROOT)<br/>
A Binary tree TREE is in memory. This procedure does<br/>
an post-order traversal of TREE applying an operation<br/>
PROCESS to each of its nodes.<br/><br/>
Step 1. if LOCALROOT ≠ NULL, than:<br/><br/>
 Call PREORDER(LEFT[LOCALROOT]. [Visit Left Child.]<br/><br/>
 Call PREORDER(RIGHT[LOCALROOT]. [Visit Right Child.]<br/><br/>
Apply PROCESS to LOCALROOT. [Visit the Node.]<br/><br/>
Set 2. Return. <br/><br/>
    "
    ]]></string>







    <string name="graph"><p ><b>GRAPH</b></p> <![CDATA["
A graph is an abstract data type that consists of V, a nonempty set of vertices (or nodes) and E, a set of edges. Each edge has either one or two vertices associated with it."]]></string>

    <string name="graph_code"> <![CDATA[
    "

import java.util.ArrayList; <br/>
import java.util.LinkedList;<br/><br/>

class Vertex{<br/><br/>
\t    public int data;<br/>
\t    public boolean isVisited;<br/><br/>

\t    public Vertex(int data){<br/>
  \t\t      this.data=data;<br/>
  \t \t }//end Vertex constructor<br/><br/>
\t}//end Vertex class<br/><br/>

public class Graph {<br/><br/>
 \t  private ArrayList < LinkedList < Vertex > > vertices;<br/>
 \t private LinkedList < Vertex > adjacencyList;<br/><br/>
\t    public Graph(){<br/>
\t\t        vertices = new ArrayList < LinkedList < Vertex > > ();<br/>
    \t\t}//end Graph constructor<br/><br/>

   \t public String addVertex(int v){<br/><br/>
     \t\t   Vertex vert = new Vertex(v);<br/><br/>
      \t\t     for(int i=0;i < vertices.size();i++)<br/>
             \t\t   \t  if(vertices.get(i).get(0).data==vert.data)<br/>
            \t\t   \t\t       return \"same vertex is not allowed\";<br/><br/>


       \t\t    adjacencyList=new LinkedList < Vertex > ();<br/>
         \t\t  adjacencyList.add(vert);<br/>
        \t\t   vertices.add(adjacencyList);<br/>
        \t\t   return vert.data +\" is added to graph\";<br/>
\t    }//end addVertex()<br/><br/>

\t public String delVert(Integer vert){<br/><br/>

     \t\t  for(int i=0;i < vertices.size();i++) {<br/>
       \t\t \t   Vertex temp = vertices.get(i).get(0);<br/>
        \t\t \t  if (temp.data == vert) {<br/>

          \t\t \t    for (int j = 0; j < vertices.size(); j++)<br/>
               \t\t   \t\t    vertices.get(j).remove(temp);<br/>
           \t\t   \t\t    vertices.remove(i);<br/>
             \t\t   \t\t  return  vert+ \" is deleted from graph\";<br/>
        \t\t \t  }<br/>
      \t\t }<br/>
      \t\t return vert+\" is not found in graph\";<br/>
\t }//end delVert()<br/><br/>

   \t public String addEdge(int u,int v){<br/><br/>
       \t\t    int i=0,j=0;<br/>
       \t\t    Vertex vertU=null,vertV=null;<br/><br/>

       \t\t    for( i=0;i < vertices.size();i++) {<br/>
            \t\t \t  if (vertices.get(i).get(0).data == u) {<br/>
            \t\t   \t\t       vertU = vertices.get(i).get(0);<br/>
            \t\t   \t\t       break;<br/>
            \t\t \t  }<br/>
       \t\t    }<br/>

  \t\t         for(j=0;j < vertices.size();j++) {<br/>
         \t\t \t     if (vertices.get(j).get(0).data == v) {<br/>
           \t\t   \t\t        vertV = vertices.get(j).get(0);<br/>
           \t\t   \t\t        break;<br/>
          \t\t \t    }<br/>
       \t\t    }<br/><br/>

      \t\t     if(vertU != null && vertV != null) {<br/>
          \t\t \t    vertices.get(j).add(vertU);<br/>
        \t\t \t      vertices.get(i).add(vertV);<br/>
         \t\t \t     return u+\" and \"+v +\" is connected through edge\";<br/>
         \t\t \t }<br/><br/>
       \t\t  \t  else if(vertU == null)<br/>
       \t  \t\t \t     return \"vertex \"+ u+ \" is not available in graph\";<br/><br/>
        \t\t \t  else if(vertV == null)<br/>
           \t\t  \t\t     return \"vertex \"+ v+ \" is not available in graph\";<br/><br/>
    \t\t  \t     return\"there is no edge between \"+u+\" and \"+ v;<br/>

     \t\t  }//end addEdge()<br/><br/>


\t public String delEdge(int u,int v){<br/><br/>
     \t\t  int i=0,j=0;<br/>
    \t\t   Vertex vertU=null,vertV=null;<br/><br/>
    \t\t   for( i=0;i < vertices.size();i++) {<br/>
      \t\t \t    if (vertices.get(i).get(0).data == u) {<br/>
          \t\t   \t\t     vertU = vertices.get(i).get(0);<br/>
         \t\t   \t\t      break;<br/>
       \t\t   \t\t    }<br/>
     \t\t  }<br/><br/>

     \t\t  for(j=0;j < vertices.size();j++) {<br/>
      \t\t \t    if (vertices.get(j).get(0).data == v) {<br/>
             \t\t   \t\t  vertV = vertices.get(j).get(0);<br/>
          \t\t   \t\t     break;<br/>
     \t\t \t     }<br/>
    \t\t   }<br/><br/>

     \t\t  if(vertU != null && vertV != null) {<br/>
  \t\t \t        vertices.get(i).remove(vertV);<br/>
        \t\t \t  vertices.get(j).remove(vertU);<br/>
         \t\t \t return u+\" and \"+v +\" is unconnected through edge\";<br/>
     \t\t  }<br/><br/>
    \t\t    if(vertU == null)<br/>
         \t\t \t return \"vertex \"+ u+ \" is not available in graph\";<br/><br/>
     \t\t  if(vertV == null)<br/>
         \t\t \t return \"vertex \"+ v+ \" is not available in graph\";<br/><br/>
     \t\t  return\"there is no edge between \"+u+\" and \"+ v;<br/>

  \t\t }//end delEdge()<br/><br/>

\t }//end Graph<br/>

"
]]></string>
    <string name="di_graph_code"> <![CDATA[
    "
import java.util.ArrayList;<br/><br/>

class Vert{<br/><br/>
 \t  public int data;<br/>
 \t  public boolean isVisited;<br/><br/>

  \t  public Vert(int data){<br/>
     \t\t      this.data=data;<br/>
\t  \t  } //end Vert contructor<br/><br/>
\t }//end Vert class<br/><br/>

public class DiGraph {<br/><br/>
    \t   private ArrayList < Vert > vertices;<br/>
     \t  private final int maxnVert = 20;<br/>
   \t    private int adjacencyMat[][];<br/>
  \t     private int nVert;<br/><br/>

  \t  public DiGraph(){<br/><br/>
      \t\t     vertices = new ArrayList < Vert > ();<br/>
       \t\t    adjacencyMat=new int[maxnVert][maxnVert];<br/>
      \t\t     nVert=0;<br/>
     \t\t      for(int i=0;i < maxnVert;i++){<br/>
            \t\t \t  for (int j = 0 ; j < maxnVert ; j++)<br/>
                 \t\t  adjacencyMat[i][j]=0;<br/><br/>
       \t\t \t   }//end for loop<br/>
      \t\t }//end DiGraph constructor<br/><br/>

    \t public String addVert(int v){<br/><br/>
        \t\t   Vert vert= new Vert(v);<br/><br/>
         \t\t  for(int i=0 ; i < vertices.size() ; i++)<br/>
             \t\t \t if(vertices.get(i).data==vert.data)<br/>
                 \t\t   \t\t  return \"same vertex is not allowed\";<br/><br/>

         \t\t  vertices.add(vert);<br/>
         \t\t  return v+\" is added in graph\";<br/>
    \t\t   }//end addVert()<br/><br/>

    \t public String delVert(int v){<br/><br/>
         \t\t  int index = getVertIndex(v);<br/><br/>

      \t\t   if( index == -1)<br/>
           \t\t \t return v+\" is not found in graph\";<br/><br/>
       \t\t  for(int i=0;i < vertices.size();i++) {<br/>
           \t\t \t adjacencyMat[index][i] = 0;<br/>
        \t\t \t    adjacencyMat[i][index] = 0;<br/>
       \t\t  }<br/><br/>
         \t\t  vertices.remove(index);<br/>
      \t\t     return v +\" is deleted from graph\";<br/>
     \t }//end delVert()<br/><br/>



   \t public String addEdge(int u,int v){<br/><br/>
       \t\t    int uIndex=0,vIndex=0;<br/>
        \t\t   uIndex=getVertIndex(u);<br/>
       \t\t    vIndex=getVertIndex(v);<br/><br/>

          \t\t if(vIndex != -1 && uIndex != -1) {<br/>
          \t\t \t    adjacencyMat[uIndex][vIndex]=1;<br/>
             \t\t  return u +\" is connected to \"+v;<br/>
       \t\t    }<br/><br/>
         \t\t  if(uIndex==-1)<br/>
           \t\t \t   return \"vertex \"+ u+ \" is not available in graph\";<br/><br/>
         \t\t  else<br/>
             \t\t \t return \"vertex \"+ v+ \" is not available in graph\";<br/><br/>

      \t\t }//end addEdge()<br/><br/>

    \t public String delEdge(int u,int v){<br/><br/>
         \t\t  int uIndex=0,vIndex=0;<br/>
      \t\t     uIndex=getVertIndex(u);<br/>
         \t\t  vIndex=getVertIndex(v);<br/>


         \t\t  if(vIndex != -1 && uIndex != -1) {<br/>
            \t\t \t  adjacencyMat[uIndex][vIndex]=0;<br/>
             \t\t \t return u +\" is unconnected from \"+v;<br/>
         \t\t  }<br/><br/>
         \t\t  if(uIndex==-1)<br/>
             \t\t \t return \"vertex \"+ u+ \" is not available in graph\";<br/><br/>
          \t\t if(vIndex==-1)<br/>
            \t\t \t  return \"vertex \"+ v+ \" is not available in graph\";<br/><br/>
         \t\t  return\"there is no edge between \\"+u+\" to \"+ v;<br/>

      \t\t }//end delEdge()<br/><br/>

    \t public int getVertIndex(int v){<br/><br/>
         \t\t  for(int i=0 ; i < vertices.size() ; i++)<br/>
           \t\t \t   if(vertices.get(i).data == v)<br/>
                \t\t   \t\t   return i;<br/><br/>

         \t\t  return  -1;<br/>
     \t\t  }//end getVertIndex()<br/>
\t }//end DiGraph class<br/>
" ]]></string>
</resources>